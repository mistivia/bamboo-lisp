(defvar nil '())

(defvar pi 3.1415926)
(defvar e 2.718281828)

(defmacro incq (i)
  `(setq ,i (+ ,i 1)))

(defmacro decq (i)
  `(setq ,i (- ,i 1)))

(defun zero? (x) (= x 0))
(defun plus? (x) (> x 0))
(defun minus? (x) (< x 0))

(defmacro when (pred . body)
  `(if ,pred
     (progn ,@body)
     nil))

(defmacro unless (pred . body)
  `(if ,pred
     nil
     (progn ,@body)))

(defun take (n lst)
  (unless (integer? n)
    (error "take: type error."))
  (unless (list? lst)
    (error "take: type error."))
  (let ((i 0)
        (newlst nil))
    (while (and (< i n)
                (not (null? lst)))
      (setq newlst (cons (car lst) newlst))
      (setq lst (cdr lst))
      (incq i))
    (nreverse newlst)))

(defun drop (n lst)
  (unless (integer? n)
    (error "drop type error."))
  (unless (list? lst)
    (error "drop: type error."))
  (let ((i 0))
    (while (and (< i n)
                (not (null? lst)))
      (setq lst (cdr lst))
      (incq i))
    lst))

(defun take-while (pred lst)
  (unless (function? pred)
    (error "take-while: type error."))
  (unless (list? lst)
    (error "take-while: type error."))
  (let ((newlst nil))
    (while (and (not (null? lst))
                (funcall pred (car lst)))
      (setq newlst (cons (car lst) newlst))
      (setq lst (cdr lst)))
    (nreverse newlst)))

(defun drop-while (pred lst)
  (unless (function? pred)
    (error "drop-while: type error."))
  (unless (list? lst)
    (error "drop-while: type error."))
  (while (and (not (null? lst))
              (funcall pred (car lst)))
    (setq lst (cdr lst)))
  lst)

(defun sublist (start end lst)
  (unless (integer? start)
    (error "sublist: type error."))
  (unless (integer? end)
    (error "sublist: type error."))
  (unless (< start end)
    (error "sublist: start must less than end."))
  (unless (list? lst)
    (error "sublist: type error."))
  (drop start (take end lst)))

(defun find (x lst)
  (unless (list? lst)
    (error "find: type error."))
  (while (not (null? lst))
    (when (equal? x (car lst))
      (return lst))
    (setq lst (cdr lst)))
  nil)

(defun contains? (x lst)
  (unless (list? lst)
    (error "contains?: type error."))
  (while (not (null? lst))
    (when (equal? x (car lst))
      (return #t))
    (setq lst (cdr lst)))
  #f)

(defun caar (x) (car (car x)))
(defun cadr (x) (car (cdr x)))
(defun cddr (x) (cdr (cdr x)))
(defun cdar (x) (cdr (car x)))

(defun caaar (x) (car (caar x)))
(defun cadar (x) (car (cdar x)))
(defun cddar (x) (cdr (cdar x)))
(defun cdaar (x) (cdr (caar x)))
(defun caadr (x) (car (cadr x)))
(defun caddr (x) (car (cddr x)))
(defun cdddr (x) (cdr (cddr x)))
(defun cdadr (x) (cdr (cadr x)))

(defun caaaar (x) (car (caaar x)))
(defun cadaar (x) (car (cdaar x)))
(defun cddaar (x) (cdr (cdaar x)))
(defun cdaaar (x) (cdr (caaar x)))
(defun caadar (x) (car (cadar x)))
(defun caddar (x) (car (cddar x)))
(defun cdddar (x) (cdr (cddar x)))
(defun cdadar (x) (cdr (cadar x)))
(defun caaadr (x) (car (caadr x)))
(defun cadadr (x) (car (cdadr x)))
(defun cddadr (x) (cdr (cdadr x)))
(defun cdaadr (x) (cdr (caadr x)))
(defun caaddr (x) (car (caddr x)))
(defun cadddr (x) (car (cdddr x)))
(defun cddddr (x) (cdr (cdddr x)))
(defun cdaddr (x) (cdr (caddr x)))
